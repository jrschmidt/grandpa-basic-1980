// Generated by CoffeeScript 1.7.1
var BasicProgram, BasicProgramLine, BooleanExpressionParser, KeyHelper, LineBuffer, LineParser, NumericExpressionParser, ParseHelpers, StringExpressionParser, SyntaxRules,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

BasicProgram = (function() {
  function BasicProgram() {
    this.lines = [];
  }

  BasicProgram.prototype.addline = function(n, text) {
    var existing;
    existing = this.lines.filter(function(ln) {
      return ln.ln_no === n;
    });
    if (existing.length === 0) {
      return this.lines.push({
        "ln_no": n,
        "text": text
      });
    } else {
      return existing[0].text = text;
    }
  };

  BasicProgram.prototype.fetch = function(line_no) {
    var existing;
    existing = this.lines.filter(function(ln) {
      return ln.ln_no === line_no;
    });
    if (existing.length === 0) {
      return {};
    } else {
      return existing[0];
    }
  };

  BasicProgram.prototype.remove = function(line_no) {
    var line;
    line = this.fetch(line_no);
    if (line !== {}) {
      line.ln_no = null;
      return line.text = null;
    }
  };

  return BasicProgram;

})();

SyntaxRules = (function() {
  function SyntaxRules() {
    this.keywords = ["CLEAR", "RUN", "INFO", "LIST", "REM", "GOTO", "GOSUB", "RETURN", "IF", "INPUT", "PRINT", "PRINTLN", "CLEARSCRN", "TAB"];
    this.keyword_tokens = ["<clear_command>", "<run_command>", "<info_command>", "<list_command>", "<remark>", "<goto>", "<gosub>", "<return>", "<if>", "<input>", "<print>", "<println>", "<clear_screen>", "<tab>"];
    this.char_tokens = ["<sp>", "<equals>", "<semicolon>", "<comma>"];
    this.chars = " =;,";
    this.action_tokens = ["<line_number>", "<line_number_statement>", "<input_statement>", "<number_variable>", "<string_variable>", "<numeric_expression>", "<string_epression>", "<boolean_expression>", "<string>", "<characters>", "<integer>"];
    this.rules = [["CLEAR"], ["RUN"], ["INFO"], ["LIST"], ["<line_number>", "<sp>", "<line_number_statement>"]];
    this.line_number_rules = [["REM", "<sp>", "<characters>"], ["REM"], ["<number_variable>", "<equals>", "<numeric_expression>"], ["<string_variable>", "<equals>", "<string_expression>"], ["GOTO", "<sp>", "<line_number>"], ["GOSUB", "<sp>", "<line_number>"], ["RETURN"], ["IF", "<sp>", "<boolean_expression>", "<sp>", "THEN", "<sp>", "<line_number>"], ["INPUT", "<sp>", "<input_statement>"], ["PRINT", "<sp>", "<string_expression>"], ["PRINTLN", "<sp>", "<string_expression>"], ["PRINTLN"], ["CLEARSCRN"], ["TAB", "<sp>", "<integer>", "<comma>", "<integer>"], ["TAB", "<sp>", "<integer>"]];
    this.input_statement_rules = [["<number_variable>"], ["<string_variable>"], ["<string>", "<semicolon>", "<number_variable>"], ["<string>", "<semicolon>", "<string_variable>"]];
  }

  return SyntaxRules;

})();

BasicProgramLine = (function() {
  function BasicProgramLine(n, str) {
    this.ln_no = n;
    this.text = str;
    this.tokens = [];
  }

  return BasicProgramLine;

})();

LineParser = (function() {
  function LineParser() {
    this.syntax = new SyntaxRules;
    this.rules = this.syntax.rules;
    this.helpers = new ParseHelpers;
  }

  LineParser.prototype.parse = function(string) {
    var match, result, rule, _i, _len, _ref;
    console.log(" ");
    console.log("PAR string = " + string);
    match = "no";
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rule = _ref[_i];
      if (match === "no") {
        result = this.look_for(string, rule);
        match = result.match;
      }
    }
    if (match === "yes") {
      return result.parse_object;
    } else {
      return "<parse_error>";
    }
  };

  LineParser.prototype.look_for = function(string, rule) {
    var cat, result, token, _i, _len;
    for (_i = 0, _len = rule.length; _i < _len; _i++) {
      token = rule[_i];
      cat = "none";
      console.log("TK look for token: " + token);
      if (__indexOf.call(this.syntax.keywords, token) >= 0) {
        cat = "keyword";
      }
      if (__indexOf.call(this.syntax.char_tokens, token) >= 0) {
        cat = "char";
      }
      if (__indexOf.call(this.syntax.action_tokens, token) >= 0) {
        cat = "action";
      }
      switch (cat) {
        case "keyword":
          console.log("TK  KEYWORD token");
          result = this.look_for_keyword(token, string);
          break;
        case "char":
          console.log("TK  CHAR token");
          result = this.look_for_char(token, string);
          break;
        case "action":
          console.log("TK  ACTION token");
          result = this.look_for_action(token, string);
          break;
        default:
          result = {
            match: "no"
          };
      }
      console.log("TK match = " + result.match);
      if (result.match === "yes") {
        console.log("TK po = " + result.parse_object);
        console.log("TK remainder = " + result.remainder);
      }
    }
    return result;
  };

  LineParser.prototype.look_for_keyword = function(token, string) {
    var find, i, key, result, vv;
    find = string.indexOf(token);
    if (find === 0) {
      console.log("KW keyword found");
      i = this.syntax.keywords.indexOf(token);
      result = {
        match: "yes",
        parse_object: [this.syntax.keyword_tokens[i]],
        remainder: string.slice(token.length)
      };
      console.log("KW (if)  result = ");
      for (key in result) {
        vv = result[key];
        console.log(key + ": " + vv);
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  return LineParser;

})();

ParseHelpers = (function() {
  function ParseHelpers() {
    this.num_exp_parser = new NumericExpressionParser;
    this.str_exp_parser = new StringExpressionParser;
    this.bool_exp_parser = new BooleanExpressionParser(this);
  }

  ParseHelpers.prototype.look_for_line_number = function(string) {
    var n, result;
    result = {};
    n = parseInt(string);
    if (n > 0) {
      result.match = "yes";
      result.parse_object = ["<line_number>", n];
      result.remainder = string.slice(String(n).length);
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_numeric_identifier = function(string) {
    var id, len, result, _ref, _ref1, _ref2;
    result = {};
    if (_ref = string[0], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref) >= 0) {
      if (_ref1 = string[1], __indexOf.call("0123456789", _ref1) >= 0) {
        len = 2;
      } else {
        len = 1;
      }
      if ((len === string.length) || (_ref2 = string[len], __indexOf.call("=+-*/^)", _ref2) >= 0)) {
        result.match = "yes";
        id = string.slice(0, len);
        result.parse_object = ["<number_variable>", id];
        result.remainder = string.slice(len);
      } else {
        result = {
          match: "no"
        };
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_string_identifier = function(string) {
    var id, len, result, _ref, _ref1, _ref2;
    result = {};
    if (string[0] === "$") {
      if (_ref = string[1], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref) >= 0) {
        if (_ref1 = string[2], __indexOf.call("0123456789", _ref1) >= 0) {
          len = 2;
        } else {
          len = 1;
        }
      }
      if ((len === string.length - 1) || (_ref2 = string[len + 1], __indexOf.call("=+", _ref2) >= 0)) {
        result.match = "yes";
        id = string.slice(1, len + 1);
        result.parse_object = ["<string_variable>", id];
        result.remainder = string.slice(len + 1);
      } else {
        result = {
          match: "no"
        };
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  return ParseHelpers;

})();

NumericExpressionParser = (function() {
  function NumericExpressionParser() {
    this.num_exp_chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "(", ")", "+", "-", "*", "/", "^"];
    this.delimiters = ["(", ")", "+", "-", "*", "/", "^"];
    this.symbols = ["<left>", "<right>", "<plus>", "<minus>", "<times>", "<divide>", "<power>"];
  }

  NumericExpressionParser.prototype.numeric_parse = function(string) {
    var bad_chars, ok, po, tk, tokens, val, _i, _len;
    bad_chars = string.search(/[^A-Z0-9\.+\-*/\^()]/);
    if (bad_chars === -1) {
      po = [];
      ok = "yes";
      tokens = this.tokenize(string);
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        tk = tokens[_i];
        if (__indexOf.call(this.symbols, tk) >= 0) {
          po.push(tk);
        } else {
          val = this.numeric_value(tk);
          if (val[0] === "bad") {
            ok = "no";
          } else {
            po.push(val[0]);
            po.push(val[1]);
          }
        }
      }
    } else {
      ok = "no";
    }
    if (ok === "no") {
      po = "<not_a_numeric_expression>";
    }
    return po;
  };

  NumericExpressionParser.prototype.tokenize = function(string) {
    var buffer, ch, tokens, _i, _len;
    tokens = [];
    buffer = "";
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      ch = string[_i];
      if (__indexOf.call(this.delimiters, ch) >= 0) {
        if (buffer !== "") {
          tokens.push(buffer);
          buffer = "";
        }
        tokens.push(this.symbols[this.delimiters.indexOf(ch)]);
      } else {
        buffer = buffer + ch;
      }
    }
    if (buffer !== "") {
      tokens.push(buffer);
    }
    return tokens;
  };

  NumericExpressionParser.prototype.numeric_value = function(string) {
    var ch, non_numerics, val, _i, _len, _ref, _ref1;
    val = [];
    if (_ref = string[0], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref) >= 0) {
      if ((string.length === 1) || (string.length === 2 && (_ref1 = string[1], __indexOf.call("0123456789", _ref1) >= 0))) {
        val[0] = "<number_variable>";
        val[1] = string;
      } else {
        val = ["bad", "bad"];
      }
    } else {
      non_numerics = "none";
      for (_i = 0, _len = string.length; _i < _len; _i++) {
        ch = string[_i];
        if (!(__indexOf.call("0123456789", ch) >= 0)) {
          if (ch === ".") {
            if (non_numerics === "one_period") {
              non_numerics = "bad";
            }
            if (non_numerics === "none") {
              non_numerics = "one_period";
            }
          } else {
            non_numerics = "bad";
          }
        }
      }
      if (non_numerics !== "bad") {
        val[0] = "<numeric_literal>";
        val[1] = Number(string);
      } else {
        val = ["bad", "bad"];
      }
    }
    return val;
  };

  return NumericExpressionParser;

})();

StringExpressionParser = (function() {
  function StringExpressionParser() {}

  StringExpressionParser.prototype.string_value_parse = function(string) {
    var ok, po, tk, tokens, val, _i, _len;
    po = [];
    ok = "yes";
    tokens = this.tokenize(string);
    for (_i = 0, _len = tokens.length; _i < _len; _i++) {
      tk = tokens[_i];
      if (tk === "<plus>") {
        po.push("<plus>");
      } else {
        val = this.string_value(tk);
        if (val[0] === "bad") {
          ok = "no";
        } else {
          po.push(val[0]);
          po.push(val[1]);
        }
      }
    }
    if (ok === "no") {
      po = "<not_a_string_expression>";
    }
    return po;
  };

  StringExpressionParser.prototype.tokenize = function(string) {
    var buffer, ch, tokens, _i, _len;
    tokens = [];
    buffer = "";
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      ch = string[_i];
      if (ch === "+") {
        if (buffer !== "") {
          tokens.push(buffer);
          buffer = "";
        }
        tokens.push("<plus>");
      } else {
        buffer = buffer + ch;
      }
    }
    if (buffer !== "") {
      tokens.push(buffer);
    }
    return tokens;
  };

  StringExpressionParser.prototype.string_value = function(string) {
    var ch, quote_check, str_var, val, _ref, _ref1, _ref2;
    val = ["bad", "bad"];
    quote_check = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = string.length; _i < _len; _i++) {
        ch = string[_i];
        if (ch === '"') {
          _results.push(ch);
        }
      }
      return _results;
    })();
    if (quote_check.length === 2 && string[0] === '"' && string[string.length - 1] === '"') {
      val[0] = "<string_literal>";
      val[1] = string.slice(1, -1);
    } else {
      str_var = "no";
      if ((_ref = string.length, __indexOf.call([2, 3], _ref) >= 0) && string[0] === "$") {
        if (_ref1 = string[1], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref1) >= 0) {
          if (string.length === 2) {
            str_var = "yes";
          } else {
            if (_ref2 = string[2], __indexOf.call("0123456789", _ref2) >= 0) {
              str_var = "yes";
            }
          }
        }
      }
      if (str_var === "yes") {
        val[0] = "<string_variable>";
        val[1] = string.slice(1);
      }
    }
    return val;
  };

  return StringExpressionParser;

})();

BooleanExpressionParser = (function() {
  function BooleanExpressionParser(parse_helpers) {
    this.helpers = parse_helpers;
  }

  BooleanExpressionParser.prototype.boolean_parse = function(string) {
    var num_exp, num_id, po, str_id, str_val, tokens;
    po = [];
    tokens = this.split(string);
    if (tokens !== "<not_a_boolean_expression>") {
      num_id = this.helpers.look_for_numeric_identifier(tokens[0]);
      if (num_id.match === "yes") {
        num_exp = this.helpers.num_exp_parser.numeric_parse(tokens[2]);
        if (num_exp !== "<not_a_numeric_expression>") {
          po = po.concat(num_id.parse_object);
          po.push(tokens[1]);
          po = po.concat(num_exp);
        }
      } else {
        str_id = this.helpers.look_for_string_identifier(tokens[0]);
        if (str_id.match === "yes") {
          str_val = this.helpers.str_exp_parser.string_value(tokens[2]);
          if (str_val[0] !== "bad") {
            po = str_id.parse_object;
            po.push("<equals>");
            po = po.concat(str_val);
          } else {
            po = "<not_a_boolean_expression>";
          }
        } else {
          po = "<not_a_boolean_expression>";
        }
      }
    } else {
      po = "<not_a_boolean_expression>";
    }
    return po;
  };

  BooleanExpressionParser.prototype.split = function(string) {
    var cut, find, po, token;
    po = [];
    token = "";
    find = string.indexOf("<");
    if (find > 0) {
      if (string[find + 1] === ">") {
        token = "<not_equal>";
      } else {
        if (string[find + 1] === "=") {
          token = "<lesser_equal>";
        } else {
          token = "<lesser_than>";
        }
      }
    }
    if (token === "") {
      find = string.indexOf(">");
      if (find > 0) {
        if (string[find + 1] === "=") {
          token = "<greater_equal>";
        } else {
          token = "<greater_than>";
        }
      }
    }
    if (token === "") {
      find = string.indexOf("=");
      if (find > 0) {
        token = "<equals>";
      }
    }
    if (token.length > 0) {
      po[0] = string.slice(0, find);
      po[1] = token;
      if (token === "<not_equal>" || token === "<lesser_equal>" || token === "<greater_equal>") {
        cut = find + 2;
      } else {
        cut = find + 1;
      }
      po[2] = string.slice(cut);
    } else {
      po = "<not_a_boolean_expression>";
    }
    return po;
  };

  return BooleanExpressionParser;

})();

KeyHelper = (function() {
  function KeyHelper() {
    this.code = [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 92, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126];
    this.chars = ["!", "DOUBLE QUOTE", "#", "$", "%", "&", "SINGLE QUOTE", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "BACK SLASH", "^", "_", "`", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "{", "|", "}", "~"];
    this.xy = [[99, 72], [33, 72], [33, 90], [77, 72], [88, 72], [44, 90], [22, 72], [66, 54], [77, 54], [33, 54], [11, 54], [55, 72], [22, 54], [44, 72], [44, 54], [0, 36], [11, 36], [22, 36], [33, 36], [44, 36], [55, 36], [66, 36], [77, 36], [88, 36], [99, 36], [0, 72], [11, 72], [88, 54], [0, 54], [99, 54], [66, 72], [22, 90], [88, 90], [55, 54], [55, 90], [0, 90], [0, 0], [11, 0], [22, 0], [33, 0], [44, 0], [55, 0], [66, 0], [77, 0], [88, 0], [99, 0], [110, 0], [121, 0], [132, 0], [0, 18], [11, 18], [22, 18], [33, 18], [44, 18], [55, 18], [66, 18], [77, 18], [88, 18], [99, 18], [110, 18], [121, 18], [132, 18], [66, 90], [99, 90], [77, 90], [11, 90]];
  }

  KeyHelper.prototype.char = function(n) {
    var ch, i;
    if (__indexOf.call(this.code, n) >= 0) {
      i = this.code.indexOf(n);
      ch = this.chars[i];
    } else {
      ch = null;
    }
    return ch;
  };

  KeyHelper.prototype.sprite_xy = function(n) {
    var i;
    if (__indexOf.call(this.code, n) >= 0) {
      i = this.code.indexOf(n);
      return this.xy[i];
    }
  };

  return KeyHelper;

})();

LineBuffer = (function() {
  function LineBuffer() {
    this.text = "";
  }

  LineBuffer.prototype.set_text = function(string) {
    return this.text = string;
  };

  LineBuffer.prototype.get_text = function() {
    return this.text;
  };

  return LineBuffer;

})();
