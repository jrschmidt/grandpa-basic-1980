// Generated by CoffeeScript 1.7.1
var BasicProgram, BasicProgramLine, KeyHelper, LineBuffer, LineParser, NumericExpressionParser, ParseHelpers, StringExpressionParser, SyntaxRules,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

BasicProgram = (function() {
  function BasicProgram() {
    this.lines = [];
  }

  BasicProgram.prototype.addline = function(n, text) {
    var existing;
    existing = this.lines.filter(function(ln) {
      return ln.ln_no === n;
    });
    if (existing.length === 0) {
      return this.lines.push({
        "ln_no": n,
        "text": text
      });
    } else {
      return existing[0].text = text;
    }
  };

  BasicProgram.prototype.fetch = function(line_no) {
    var existing;
    existing = this.lines.filter(function(ln) {
      return ln.ln_no === line_no;
    });
    if (existing.length === 0) {
      return {};
    } else {
      return existing[0];
    }
  };

  BasicProgram.prototype.remove = function(line_no) {
    var line;
    line = this.fetch(line_no);
    if (line !== {}) {
      line.ln_no = null;
      return line.text = null;
    }
  };

  return BasicProgram;

})();

SyntaxRules = (function() {
  function SyntaxRules() {
    this.keywords = ["CLEAR", "RUN", "INFO", "LIST", "REM", "GOTO", "GOSUB", "RETURN", "IF", "INPUT", "PRINT", "PRINTLN", "TAB"];
    this.keyword_tokens = ["<clear_keyword>", "<run_command>", "<info_command>", "<list_command>", "<remark>", "<goto>", "<gosub>", "<return>", "<if>", "<input>", "<print>", "<println>", "<tab>"];
    this.char_tokens = ["<sp>", "<equals>", "<semicolon>", "<comma>"];
    this.action_tokens = ["<line_number>", "<number_variable>", "<string_variable>", "<numeric_expression>", "<string_epression>", "<boolean_expression>", "<string>", "<characters>", "<integer>"];
    this.rules = [["CLEAR"], ["RUN"], ["INFO"], ["LIST"], ["<line_number>", "<sp>", this.line_number_rules]];
    this.line_number_rules = [["REM", "<sp>", "<characters>"], ["REM"], ["<number_variable>", "<equals>", "<numeric_expression>"], ["<string_variable>", "<equals>", "<string_expression>"], ["GOTO", "<sp>", "<line_number>"], ["GOSUB", "<sp>", "<line_number>"], ["RETURN"], ["IF", "<sp>", "<boolean_expression>", "<sp>", "THEN", "<sp>", "<line_number>"], ["INPUT", "<sp>", this.input_statement_rules], ["PRINT", "<sp>", "<string_expression>"], ["PRINTLN", "<sp>", "<string_expression>"], ["PRINTLN"], ["CLEAR"], ["TAB", "<sp>", "<integer>", "<comma>", "<integer>"], ["TAB", "<sp>", "<integer>"]];
    this.input_statement_rules = [["number_variable>"], ["string_variable>"], ["<string>", "<semicolon>", "<number_variable>"], ["<string>", "<semicolon>", "<string_variable>"]];
  }

  return SyntaxRules;

})();

BasicProgramLine = (function() {
  function BasicProgramLine(n, str) {
    this.ln_no = n;
    this.text = str;
    this.tokens = [];
  }

  return BasicProgramLine;

})();

LineParser = (function() {
  function LineParser() {
    this.rules = new SyntaxRules;
    this.helpers = new ParseHelpers;
  }

  LineParser.prototype.parse = function(string) {
    var po;
    po = [];
    return po;
  };

  return LineParser;

})();

ParseHelpers = (function() {
  function ParseHelpers() {}

  ParseHelpers.prototype.look_for_line_number = function(string) {
    var n, result;
    result = {};
    n = parseInt(string);
    if (n > 0) {
      result.match = "yes";
      result.parse_object = ["<line_number>", n];
      result.remainder = string.slice(String(n).length);
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_numeric_identifier = function(string) {
    var id, len, result, _ref, _ref1, _ref2;
    result = {};
    if (_ref = string[0], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref) >= 0) {
      if (_ref1 = string[1], __indexOf.call("0123456789", _ref1) >= 0) {
        len = 2;
      } else {
        len = 1;
      }
      if ((len === string.length) || (_ref2 = string[len], __indexOf.call("=+-*/^)", _ref2) >= 0)) {
        result.match = "yes";
        id = string.slice(0, len);
        result.parse_object = ["<number_variable>", id];
        result.remainder = string.slice(len);
      } else {
        result = {
          match: "no"
        };
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  ParseHelpers.prototype.look_for_string_identifier = function(string) {
    var id, len, result, _ref, _ref1, _ref2;
    result = {};
    if (string[0] === "$") {
      if (_ref = string[1], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref) >= 0) {
        if (_ref1 = string[2], __indexOf.call("0123456789", _ref1) >= 0) {
          len = 2;
        } else {
          len = 1;
        }
      }
      if ((len === string.length - 1) || (_ref2 = string[len + 1], __indexOf.call("=+", _ref2) >= 0)) {
        result.match = "yes";
        id = string.slice(1, len + 1);
        result.parse_object = ["<string_variable>", id];
        result.remainder = string.slice(len + 1);
      } else {
        result = {
          match: "no"
        };
      }
    } else {
      result = {
        match: "no"
      };
    }
    return result;
  };

  return ParseHelpers;

})();

NumericExpressionParser = (function() {
  function NumericExpressionParser() {
    this.num_exp_chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "(", ")", "+", "-", "*", "/", "^"];
    this.delimiters = ["(", ")", "+", "-", "*", "/", "^"];
    this.symbols = ["<left>", "<right>", "<plus>", "<minus>", "<times>", "<divide>", "<power>"];
  }

  NumericExpressionParser.prototype.numeric_parse = function(string) {
    var bad_chars, ok, po, tk, tokens, val, _i, _len;
    bad_chars = string.search(/[^A-Z0-9\.+\-*/\^()]/);
    if (bad_chars === -1) {
      po = [];
      ok = "yes";
      tokens = this.tokenize(string);
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        tk = tokens[_i];
        if (__indexOf.call(this.symbols, tk) >= 0) {
          po.push(tk);
        } else {
          val = this.numeric_value(tk);
          if (val[0] === "bad") {
            ok = "no";
          } else {
            po.push(val[0]);
            po.push(val[1]);
          }
        }
      }
    } else {
      ok = "no";
    }
    if (ok === "no") {
      po = "<not_a_numeric_expression>";
    }
    return po;
  };

  NumericExpressionParser.prototype.tokenize = function(string) {
    var buffer, ch, tokens, _i, _len;
    tokens = [];
    buffer = "";
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      ch = string[_i];
      if (__indexOf.call(this.delimiters, ch) >= 0) {
        if (buffer !== "") {
          tokens.push(buffer);
          buffer = "";
        }
        tokens.push(this.symbols[this.delimiters.indexOf(ch)]);
      } else {
        buffer = buffer + ch;
      }
    }
    if (buffer !== "") {
      tokens.push(buffer);
    }
    return tokens;
  };

  NumericExpressionParser.prototype.numeric_value = function(string) {
    var ch, non_numerics, val, _i, _len, _ref, _ref1;
    val = [];
    if (_ref = string[0], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref) >= 0) {
      if ((string.length === 1) || (string.length === 2 && (_ref1 = string[1], __indexOf.call("0123456789", _ref1) >= 0))) {
        val[0] = "<number_variable>";
        val[1] = string;
      } else {
        val = ["bad", "bad"];
      }
    } else {
      non_numerics = "none";
      for (_i = 0, _len = string.length; _i < _len; _i++) {
        ch = string[_i];
        if (!(__indexOf.call("0123456789", ch) >= 0)) {
          if (ch === ".") {
            if (non_numerics === "one_period") {
              non_numerics = "bad";
            }
            if (non_numerics === "none") {
              non_numerics = "one_period";
            }
          } else {
            non_numerics = "bad";
          }
        }
      }
      if (non_numerics !== "bad") {
        val[0] = "<numeric_literal>";
        val[1] = Number(string);
      } else {
        val = ["bad", "bad"];
      }
    }
    return val;
  };

  return NumericExpressionParser;

})();

StringExpressionParser = (function() {
  function StringExpressionParser() {}

  StringExpressionParser.prototype.tokenize = function(string) {
    var buffer, ch, tokens, _i, _len;
    tokens = [];
    buffer = "";
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      ch = string[_i];
      if (ch === "+") {
        if (buffer !== "") {
          tokens.push(buffer);
          buffer = "";
        }
        tokens.push("<plus>");
      } else {
        buffer = buffer + ch;
      }
    }
    if (buffer !== "") {
      tokens.push(buffer);
    }
    return tokens;
  };

  StringExpressionParser.prototype.string_value = function(string) {
    var ch, quote_check, str_var, val, _ref, _ref1, _ref2;
    val = ["bad", "bad"];
    quote_check = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = string.length; _i < _len; _i++) {
        ch = string[_i];
        if (ch === '"') {
          _results.push(ch);
        }
      }
      return _results;
    })();
    if (quote_check.length === 2 && string[0] === '"' && string[string.length - 1] === '"') {
      val[0] = "<string_literal>";
      val[1] = string.slice(1, -1);
    } else {
      str_var = "no";
      if ((_ref = string.length, __indexOf.call([2, 3], _ref) >= 0) && string[0] === "$") {
        if (_ref1 = string[1], __indexOf.call("ABCDEFGHIJKLMNOPQRSTUVWXYZ", _ref1) >= 0) {
          if (string.length === 2) {
            str_var = "yes";
          } else {
            if (_ref2 = string[2], __indexOf.call("0123456789", _ref2) >= 0) {
              str_var = "yes";
            }
          }
        }
      }
      if (str_var === "yes") {
        val[0] = "<string_variable>";
        val[1] = string.slice(1);
      }
    }
    return val;
  };

  return StringExpressionParser;

})();

KeyHelper = (function() {
  function KeyHelper() {
    this.code = [33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 92, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126];
    this.chars = ["!", "DOUBLE QUOTE", "#", "$", "%", "&", "SINGLE QUOTE", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "BACK SLASH", "^", "_", "`", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "{", "|", "}", "~"];
    this.xy = [[99, 72], [33, 72], [33, 90], [77, 72], [88, 72], [44, 90], [22, 72], [66, 54], [77, 54], [33, 54], [11, 54], [55, 72], [22, 54], [44, 72], [44, 54], [0, 36], [11, 36], [22, 36], [33, 36], [44, 36], [55, 36], [66, 36], [77, 36], [88, 36], [99, 36], [0, 72], [11, 72], [88, 54], [0, 54], [99, 54], [66, 72], [22, 90], [88, 90], [55, 54], [55, 90], [0, 90], [0, 0], [11, 0], [22, 0], [33, 0], [44, 0], [55, 0], [66, 0], [77, 0], [88, 0], [99, 0], [110, 0], [121, 0], [132, 0], [0, 18], [11, 18], [22, 18], [33, 18], [44, 18], [55, 18], [66, 18], [77, 18], [88, 18], [99, 18], [110, 18], [121, 18], [132, 18], [66, 90], [99, 90], [77, 90], [11, 90]];
  }

  KeyHelper.prototype.char = function(n) {
    var ch, i;
    if (__indexOf.call(this.code, n) >= 0) {
      i = this.code.indexOf(n);
      ch = this.chars[i];
    } else {
      ch = null;
    }
    return ch;
  };

  KeyHelper.prototype.sprite_xy = function(n) {
    var i;
    if (__indexOf.call(this.code, n) >= 0) {
      i = this.code.indexOf(n);
      return this.xy[i];
    }
  };

  return KeyHelper;

})();

LineBuffer = (function() {
  function LineBuffer() {
    this.text = "";
  }

  LineBuffer.prototype.set_text = function(string) {
    return this.text = string;
  };

  LineBuffer.prototype.get_text = function() {
    return this.text;
  };

  return LineBuffer;

})();
